# Instruction Set Architecture

This chapter describes the MISA instruction set architecture, include the base instruction set,
optional assembler extensions, special registers and hardware data structures, and other
implementation-agnostic features.

The MISA architecture is an 8-bit architecture with up to a 16-bit address bus to interface with
externally connected memory. Instructions are fixed-with 16-bit doublewords in little-endian byte
order.

## Registers

Two types of registers are visible to the programmer in various contexts.

### General Purpose Registers

The general-purpose register file contains sixteen, 8-bit registers for generate computation and
data storage, defined by the following ABI:

| ABI Name | Wide ABI Name | Encoding |
|----------|---------------|----------|
| `R0`     | N/A           | 0000     |
| `RA`     | `RAB`         | 0001     |
| `RB`     |               | 0010     |
| `RC`     | `RCD`         | 0011     |
| `RD`     |               | 0100     |
| `RE`     | `REF`         | 0101     |
| `RF`     |               | 0110     |
| `RG`     | `RGH`         | 0111     |
| `RH`     |               | 1000     |
| `RU`     | `RUV`         | 1001     |
| `RV`     |               | 1010     |
| `RW`     | `RWX`         | 1011     |
| `RX`     |               | 1100     |
| `RY`     | `RYZ`         | 1101     |
| `RZ`     |               | 1110     |
| `RT`     | N/A           | 1111     |

The `R0` register must be hard-wired to ignore writes and always return the value `0b00000000` on
reads. Wide registers are formed by two general-purpose registers, which must be equivalent to
using the two 8-bit register names in order. For instance, `RAB` is semantically equivalent to
`RA, RB` in that order.

General purpose registers can be taken as the operands to most instructions which operate on
registers.

### Control and Status Registers

Also required are a few special registers, which cannot be used as instruction operands, but can
be read and written from general purpose registers with the `RSR` and `WSR` instructions. Special
registers are generally wider 16-bit registers that are required for the operation of certain
instructions.

#### `SADDR`

The stack address or stack pointer. `SADDR` must be at least an 8-bit register and no more than a
16-bit register supporting values from `0x00` to `0xFF`.

The instruction set architecture recommends an 8-bit `SADDR` register which defines a hardware
stack at the second 256-byte page from `0x0100` to `0x01FF`. Implementations may also optionally
define a 16-bit `SADDR` register which can freely access a stack at any location in the mappable
address space, or any width in-between.

```{python}
#| echo: false
import wavedrom
from IPython.display import SVG
SVG(wavedrom.render(str({
    "reg": [
        {"name": "SADDR LO (required)", "bits": 8},
        {"name": "SADDR HI (optional)", "bits": 8}
    ],
    "config": {"bits": 16}
})).tostring())
```

#### `RADDR`

The return address is also a dedicated special register given the limited number of general
purpose registers available. `RADDR` is required to be wide enough to store an absolute address
for the connected memory, which generally means 16-bit.

The return address special register is not used by specific base instructions, but provides a
dedicated 16-bit-wide register for subroutine calling. The linking `JAL` instruction sets the
`RADDR` register with the address of the instruction after the `JAL`. Returning to the location
in `RADDR` requiring a `RSR` and `JMP`.

```{python}
#| echo: false
import wavedrom
from IPython.display import SVG
SVG(wavedrom.render(str({
    "reg": [
        {"name": "RADDR", "bits": 16},
    ],
    "config": {"bits": 16}
})).tostring())
```

#### `FLAGS`

Conditional branching in the MISA architecture is based on ALU flag values for comparing integers.
Both branching instructions, `JAL` and `JMP`, use these flags to make decisions on whether a branch
will be taken.

`FLAGS` is set based on the result of each ALU operation. For instructions which do not use the ALU,
it is implementation-defined whether or not `FLAGS` will be updated, although programmers should
never assume that `FLAGS` will persist across multiple instructions. A conditional branch that
relies on `FLAGS` must be performed immediately after the conditional comparison or a `WSR` to
`FLAGS`.

The `FLAGS` special register is a flags register (one bit per flag) which must be at least 4 bits
and support the following:

| Flag | Bit | Commentary                                                           |
|------|-----|----------------------------------------------------------------------|
| `Z`  | 0   | Whether the last ALU operation's output was zero.                    |
| `C`  | 1   | The adder carry out bit of the last ALU operation.                   |
| `N`  | 2   | Whether the last ALU operation's output was negative (MSB = 1).      |
| `V`  | 3   | Whether the last ALU operation's output overflowed (sign inversion). |

```{python}
#| echo: false
import wavedrom
from IPython.display import SVG
SVG(wavedrom.render(str({
    "reg": [
        {"name": "Z", "bits": 1},
        {"name": "C", "bits": 1},
        {"name": "N", "bits": 1},
        {"name": "V", "bits": 1},
        {"name": "Reserved (optional)", "bits": 12}
    ],
    "config": {"bits": 16}
})).tostring())
```

The `FLAGS` register can be accessed indirectly with the conditional jump instructions using
special assembler symbols:

| Symbol          | Operation        | Encoding |
|-----------------|------------------|----------|
| `ALWAYS`        | `1`              | 0000     |
| `EQUAL`         | `Z`              | 0001     |
| `NOT_EQUAL`     | `~Z`             | 1000     |
| `GREATER`       | `~((N ^ V) | Z)` | 0010     |
| `LESS`          | `N ^ V`          | 0100     |
| `GREATER_EQUAL` | `~(N ^ V)`       | 0011     |
| `LESS_EQUAL`    | `(N ^ V) | Z`    | 0101     |

These comparison flags, when passed as a conditional branch instruction operand, must perform
the specified boolean logic on the fields of the `FLAGS` register. If the result is `1`, the
branch is taken, otherwise the branch is not taken. The assumption is that a comparison of
registers `RS1` and `RS2` is performed by invoking `SUB R0 RS1 RS2`, which sets the ALU flags
appropriately for deciding `RS1 ? RS2` where `?` is a comparison operator.

## Memory

The MISA architecture supports up to a 16-bit address bus for memory operations, and memory must
be byte-addressable. While the memory map for applications using the MISA architecture is generally
free for the user to decide, this section will cover both a recommended map and specific regions
which are required by all maps.

### Required Memory Regions

Addresses 0xFFFA - 0xFFFF are reserved for a three-element hardware vector array and must always
contain the following function pointers (which are absolute 16-bit addresses):

| Vector Address  | Commentary   |
|-----------------|--------------|
| 0xFFFA - 0xFFFB | (Reserved)   |
| 0xFFFC - 0xFFFD | (Reserved)   |
| 0xFFFE - 0xFFFF | Reset vector |

When power is supplied, the microprocessor must load the program counter to be:
`PC = Memory[0xFFFF] << 8 | Memory[0xFFFE]`.

### Recommended Memory Map

The linker script recommended by default is as follows:
```
SECTION 0x0000 - 0x00FF : direct ;       // Zero page, which may have fast access on some hardware
SECTION 0x0100 - 0X01FF : ;              // Stack, SADDR initialized to 0x(01)FF and decrements
SECTION 0x0200 - 0x7FFF : data bss ;     // RAM, may support software-implemented stack or heap
SECTION 0x8000 - 0xBFFF : ;              // Memory-mapped IO and IO buffers
SECTION 0xC000 - 0xFFF0 : text rodata ;  // Program ROM
SECTION 0xFFFA - 0xFFFF : vectors ;      // Hardware vector addresses, described above
```

Which define the following sections by convention:

| Section   | Commentary                                                                                                                                                                                         |
|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `direct`  | Contents to place in the first 256-byte page. This page may support faster memory operations on certain hardware implementations, and thus may be a desirable target for frequently accessed data. |
| `data`    | Initialized global data that is mutable.                                                                                                                                                           |
| `bss`     | Declared but uninitialized global data that is mutable. Runtime/startup code should initialize `bss` symbols to zero.                                                                              |
| `text`    | Executable and immutable program code.                                                                                                                                                             |
| `rodata`  | Initialized global constants.                                                                                                                                                                      |
| `vectors` | The three required hardware vector addresses.                                                                                                                                                      |

## Base Instructions

Only 16 base instructions (with distinct opcodes and behavior) are supported by the MISA
architecture. This is a hard limit, and the 8-bit MISA architecture does not allow for more than
4 bits of opcode in each instruction word. This subsection defines all the base instructions
and their behavior on the microprocessor's state.

### `HALT`
Usage: `HALT RS`

Meaning: `exit(RS)`

Description: Halt the processor and emit the contents of `RS` for debug.

Encoding:
```{python}
#| echo: false
import wavedrom
from IPython.display import SVG
SVG(wavedrom.render(str({
    "reg": [
        *[{"name": bit, "bits": 1} for bit in reversed("0000")],
        {"name": "RS", "bits": 4},
        {"name": "Unused", "bits": 8}
    ],
    "config": {"bits": 16}
})).tostring())
```

### `ADD`
Usage: `ADD RD RS1 RS2`

Meaning: `RD = RS1 + RS2`

Description: Add the content of `RS1` and `RS2` and store the result in `RD`.

Encoding:
```{python}
#| echo: false
import wavedrom
from IPython.display import SVG
SVG(wavedrom.render(str({
    "reg": [
        *[{"name": bit, "bits": 1} for bit in reversed("0001")],
        {"name": "RD", "bits": 4},
        {"name": "RS1", "bits": 4},
        {"name": "RS2", "bits": 4}
    ],
    "config": {"bits": 16}
})).tostring())
```

### `ADC`
Usage: `ADC RD RS1 RS2`

Meaning: `RD = RS1 + RS2 + C`

Description: Add the contents of `RS1`, `RS2`, and the `C` field of the `FLAGS` register and
store the result in `RD`.

Encoding:
```{python}
#| echo: false
import wavedrom
from IPython.display import SVG
SVG(wavedrom.render(str({
    "reg": [
        *[{"name": bit, "bits": 1} for bit in reversed("0010")],
        {"name": "RD", "bits": 4},
        {"name": "RS1", "bits": 4},
        {"name": "RS2", "bits": 4}
    ],
    "config": {"bits": 16}
})).tostring())
```

### `SUB`
Usage: `SUB RD RS1 RS2`

Meaning: `RD = RS1 - RS2`

Description: Subtract the contents of `RS2` from `RS1` and store the result in `RD`.

Encoding:
```{python}
#| echo: false
import wavedrom
from IPython.display import SVG
SVG(wavedrom.render(str({
    "reg": [
        *[{"name": bit, "bits": 1} for bit in reversed("0011")],
        {"name": "RD", "bits": 4},
        {"name": "RS1", "bits": 4},
        {"name": "RS2", "bits": 4}
    ],
    "config": {"bits": 16}
})).tostring())
```

### `SBB`
Usage: `SBB RD RS1 RS2`

Meaning: `RD = RS1 - (RS2 + C)`

Description: Subtract the contents of `RS2` and the `C` field of the `FLAGS` register, as one
partial sum, from the contents of `RS1`, and store the result in `RD`.

Encoding:
```{python}
#| echo: false
import wavedrom
from IPython.display import SVG
SVG(wavedrom.render(str({
    "reg": [
        *[{"name": bit, "bits": 1} for bit in reversed("0100")],
        {"name": "RD", "bits": 4},
        {"name": "RS1", "bits": 4},
        {"name": "RS2", "bits": 4}
    ],
    "config": {"bits": 16}
})).tostring())
```

### `AND`
Usage: `AND RD RS1 RS2`

Meaning: `RD = RS1 & RS2`

Description: Compute the bitwise AND of the contents of `RS1` and `RS2` and store the result
in `RD`.

Encoding:
```{python}
#| echo: false
import wavedrom
from IPython.display import SVG
SVG(wavedrom.render(str({
    "reg": [
        *[{"name": bit, "bits": 1} for bit in reversed("0101")],
        {"name": "RD", "bits": 4},
        {"name": "RS1", "bits": 4},
        {"name": "RS2", "bits": 4}
    ],
    "config": {"bits": 16}
})).tostring())
```

### `OR`
Usage: `OR RD RS1 RS2`

Meaning: `RD = RS1 | RS2`

Description: Compute the bitwise OR of the contents of `RS1` and `RS2` and store the result in `RD`.

Encoding:
```{python}
#| echo: false
import wavedrom
from IPython.display import SVG
SVG(wavedrom.render(str({
    "reg": [
        *[{"name": bit, "bits": 1} for bit in reversed("0110")],
        {"name": "RD", "bits": 4},
        {"name": "RS1", "bits": 4},
        {"name": "RS2", "bits": 4}
    ],
    "config": {"bits": 16}
})).tostring())
```

### `XOR`
Usage: `XOR RD RS1 RS2`

Meaning: `RD = RS1 ^ RS2`

Description: Compute the bitwise exclusive OR of the contents of `RS1` and `RS2` and store the
result in `RD`.

Encoding:
```{python}
#| echo: false
import wavedrom
from IPython.display import SVG
SVG(wavedrom.render(str({
    "reg": [
        *[{"name": bit, "bits": 1} for bit in reversed("0111")],
        {"name": "RD", "bits": 4},
        {"name": "RS1", "bits": 4},
        {"name": "RS2", "bits": 4}
    ],
    "config": {"bits": 16}
})).tostring())
```

### `RRC`
Usage: `RRC RD RS`

Meaning: `RD = (C << 7) | (RS >> 1) ; C = RS & 1`

Description: Shift the 9-bit integer formed by `{C, RS}` right by one bit. Store the shifted
result in `RD` and the LSB of `RS` into `C`.

Encoding:
```{python}
#| echo: false
import wavedrom
from IPython.display import SVG
SVG(wavedrom.render(str({
    "reg": [
        *[{"name": bit, "bits": 1} for bit in reversed("1000")],
        {"name": "RD", "bits": 4},
        {"name": "RS", "bits": 4},
        {"name": "Unused", "bits": 4}
    ],
    "config": {"bits": 16}
})).tostring())
```

### `SET`
Usage: `SET RD IMM`

Meaning: `RD = IMM`

Description: Store the provided 8-bit immediate value into `RD`.

Encoding:
```{python}
#| echo: false
import wavedrom
from IPython.display import SVG
SVG(wavedrom.render(str({
    "reg": [
        *[{"name": bit, "bits": 1} for bit in reversed("1001")],
        {"name": "RD", "bits": 4},
        {"name": "IMM", "bits": 8}
    ],
    "config": {"bits": 16}
})).tostring())
```

### `LW`
Usage: `LW RD RS1 RS2`

Meaning: `RD = Memory[RS1 << 8 | RS2]`

Description: Load the 8-bit word at the address formed by `{RS1, RS2}` into `RD`.

Encoding:
```{python}
#| echo: false
import wavedrom
from IPython.display import SVG
SVG(wavedrom.render(str({
    "reg": [
        *[{"name": bit, "bits": 1} for bit in reversed("1010")],
        {"name": "RD", "bits": 4},
        {"name": "RS1", "bits": 4},
        {"name": "RS2", "bits": 4}
    ],
    "config": {"bits": 16}
})).tostring())
```

### `SW`
Usage: `SW RD RS1 RS2`

Meaning: `Memory[RS1 << 8 | RS2] = RD`

Description: Store the 8-bit word in `RD` to the address formed by `{RS1, RS2}`.

Encoding:
```{python}
#| echo: false
import wavedrom
from IPython.display import SVG
SVG(wavedrom.render(str({
    "reg": [
        *[{"name": bit, "bits": 1} for bit in reversed("1011")],
        {"name": "RD", "bits": 4},
        {"name": "RS1", "bits": 4},
        {"name": "RS2", "bits": 4}
    ],
    "config": {"bits": 16}
})).tostring())
```

### `RSR`
Usage: `RSR CSR RS1 RS2`

Meaning: `RS1 = CSR >> 8 ; RS2 = CSR & 0xFF`

Description: Read the 16-bit control and status register `CSR` into the two 8-bit general purpose
registers `{RS1, RS2}`

Encoding:
```{python}
#| echo: false
import wavedrom
from IPython.display import SVG
SVG(wavedrom.render(str({
    "reg": [
        *[{"name": bit, "bits": 1} for bit in reversed("1100")],
        {"name": "CSR", "bits": 4},
        {"name": "RS1", "bits": 4},
        {"name": "RS2", "bits": 4}
    ],
    "config": {"bits": 16}
})).tostring())
```

### `WSR`
Usage: `WSR CSR RS1 RS2`

Meaning: `CSR = RS1 << 8 | RS2`

Description: Write the contents formed by `{RS1, RS2}` into the 16-bit control and status
register `CSR`.

Encoding:
```{python}
#| echo: false
import wavedrom
from IPython.display import SVG
SVG(wavedrom.render(str({
    "reg": [
        *[{"name": bit, "bits": 1} for bit in reversed("1101")],
        {"name": "CSR", "bits": 4},
        {"name": "RS1", "bits": 4},
        {"name": "RS2", "bits": 4}
    ],
    "config": {"bits": 16}
})).tostring())
```

### `JAL`
Usage: `JAL CMP RS1 RS2`

Meaning: `if (CMP) { RADDR = PC + 2 ; PC = RS1 << 8 | RS2 }`

Description: If the comparison type `CMP` is true as determined by the current ALU flags, set
`RADDR` to the address of the next instruction and set `PC` to the address formed by `{RS1, RS2}`.

Encoding:
```{python}
#| echo: false
import wavedrom
from IPython.display import SVG
SVG(wavedrom.render(str({
    "reg": [
        *[{"name": bit, "bits": 1} for bit in reversed("1110")],
        {"name": "CMP", "bits": 4},
        {"name": "RS1", "bits": 4},
        {"name": "RS2", "bits": 4}
    ],
    "config": {"bits": 16}
})).tostring())
```

### `JMP`
Usage: `JMP CMP RS1 RS2`

Meaning: `if (CMP) { PC = RS1 << 8 | RS2 }`

Description: If the comparison type `CMP` is true as determined byt he current ALU flags, set
`PC` to the address formed by `{RS1, RS2}`.

Encoding:
```{python}
#| echo: false
import wavedrom
from IPython.display import SVG
SVG(wavedrom.render(str({
    "reg": [
        *[{"name": bit, "bits": 1} for bit in reversed("1111")],
        {"name": "CMP", "bits": 4},
        {"name": "RS1", "bits": 4},
        {"name": "RS2", "bits": 4}
    ],
    "config": {"bits": 16}
})).tostring())
```

## Pseudo Instructions
